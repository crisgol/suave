<script>
  import { getContext, onDestroy } from 'svelte';
  import { isComponent, isPromise } from './utils';
  import { getRouter, setMatch } from './context';

  export let path;
  export let component;
  export let preload;

  // These are generated by @suave/router/preprocess
  // path -> path-to-regexp -> { matches, rank }
  export let matches;
  export let rank;

  let props;
  // export let default -> props.default
  // export let catch -> props.catch
  
  const router = getRouter();
  
  let Component = null;
  $: {
    if (component && isComponent(component)) {
      // Simulate () => import('./Component.html')
      // (but not async -> needed for SSR)
      Component = () => ({ default: component, preload });
    } else if (component && isPromise(component)) {
      // Assume promise is import('./Component.html'), wrap in function
      Component = () => component;
    } else {
      // Component is either import function or nothing
      Component = component || null;
    }
  }
  
  const match = router.register({
    path,
    matches,
    rank,
    default: props.default,
    catch: props.catch
  });
  $: match.setComponent(Component);

  setMatch(match);
  onDestroy(() => router.unregister(match));
</script>

<svelte:options bind:props />

{#if $match}
  {#if $match.loading}
    {#await $match.loading}
      <slot name="loading" {...$match.params} />
    {:then result}
      <svelte:component this={result.Component} {...result.preloaded}>
        <slot {...$match.params} />
      </svelte:component>
    {/await}
  {:else}
    <slot {...$match.params} />
  {/if}
{/if}
